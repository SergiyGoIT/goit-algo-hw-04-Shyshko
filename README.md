Порівняння алгоритмів сортування
Це домашнє завдання присвячене порівнянню трьох алгоритмів сортування: сортування вставками, сортування злиттям і Timsort (вбудована функція Python sorted). Аналіз виконано шляхом тестування алгоритмів на різних наборах даних із використанням модуля timeit для вимірювання часу виконання. Результати підтверджують теоретичні оцінки складності та демонструють переваги Timsort.
Опис завдання
Мета завдання — порівняти ефективність трьох алгоритмів сортування:

Сортування вставками (Insertion Sort)
Сортування злиттям (Merge Sort)
Timsort (вбудована функція sorted)

Алгоритми тестувалися на наборах даних різного типу:

Випадкові дані: Масиви зі значеннями від 0 до 10000.
Відсортовані дані: Випадковий масив, відсортований за зростанням.
Зворотно відсортовані дані: Відсортований масив у зворотному порядку.
Дані з дублікатами: Масиви зі значеннями від 0 до 100 для створення дублікатів.

Тестування проводилося для масивів розміром 100, 1000, 5000 і 10000 елементів. Час виконання вимірювався за допомогою модуля timeit (середній час із 10 повторів). Результати збережено у файл sorting_results.txt, а графіки порівняння — у файли sorting_comparison_*.png.
Теоретичні оцінки складності

Сортування вставками:

Середня та найгірша складність: O(n²).
Найкращий випадок: O(n) для майже відсортованих масивів.
Переваги: Простота реалізації, ефективність на малих і майже відсортованих масивах.
Недоліки: Погано масштабується на великих масивах.

Сортування злиттям:

Складність: O(n log n) у всіх випадках (найкращий, середній, найгірший).
Переваги: Стабільна продуктивність, гарантована швидкість незалежно від типу даних.
Недоліки: Потребує додаткової пам’яті O(n).

Timsort:

Середня складність: O(n log n).
Найкращий випадок: O(n) для майже відсортованих масивів.
Переваги: Адаптивний алгоритм, що поєднує сортування вставками (для малих підмасивів) і злиттям (для великих масивів). Оптимізує продуктивність за рахунок виявлення вже відсортованих ділянок.
Недоліки: Складніша реалізація, але вбудована в Python.

Емпіричні результати
Результати тестування підтверджують теоретичні оцінки:

Сортування вставками:

Найповільніше на великих масивах (наприклад, 10000 елементів: ~2–3 секунди для випадкових даних).
Найшвидше на майже відсортованих масивах малого розміру (100 елементів: ~0.0002 секунди).
Показує квадратичну залежність часу виконання від розміру масиву.

Сортування злиттям:

Стабільна продуктивність на всіх типах даних (~0.02–0.03 секунди для 10000 елементів).
Значно швидше за сортування вставками на великих масивах.
Незалежність від структури даних підтверджує O(n log n).

Timsort:

Найшвидший у всіх тестах (~0.005–0.007 секунди для 10000 елементів на випадкових даних).
Особливо ефективний на відсортованих і майже відсортованих масивах (~0.0001 секунди для 100 елементів).
Адаптивність дозволяє оптимізувати обробку даних із частковою впорядкованістю.

Детальні результати збережено у файлі sorting_results.txt. Графіки порівняння часу виконання для кожного типу даних знаходяться у файлах sorting_comparison_random.png, sorting_comparison_sorted.png, sorting_comparison_reverse_sorted.png і sorting_comparison_duplicated.png.
Чому Timsort ефективніший?
Timsort є гібридним алгоритмом, який поєднує переваги сортування вставками та злиттям:

Сортування вставками для малих підмасивів: Timsort розбиває масив на невеликі "runs" (послідовності) і сортує їх вставками, що ефективно для малих розмірів (зазвичай до 64 елементів).
Сортування злиттям для великих масивів: Великі підмасиви об’єднуються за допомогою злиття, що забезпечує стабільну продуктивність O(n log n).
Адаптивність: Timsort виявляє вже відсортовані або частково відсортовані ділянки, зменшуючи кількість операцій. Це робить його особливо швидким для відсортованих і майже відсортованих даних (O(n) у найкращому випадку).
Оптимізація пам’яті: Timsort мінімізує використання додаткової пам’яті під час злиття порівняно з класичним сортуванням злиттям.

Ці особливості роблять Timsort значно швидшим за чисті реалізації сортування вставками чи злиттям у реальних сценаріях, де дані часто мають часткову впорядкованість.
Висновки

Сортування вставками:

Підходить для малих масивів (до 100 елементів) або майже відсортованих даних.
Непрактичне для великих масивів через квадратичну складність O(n²).


Сортування злиттям:

Забезпечує стабільну продуктивність O(n log n) незалежно від типу даних.
Краще за сортування вставками для великих масивів, але потребує додаткової пам’яті.


Timsort:

Найшвидший у всіх тестах завдяки гібридному підходу.
Поєднання сортування вставками та злиттям дозволяє оптимізувати продуктивність для різних типів даних.
Адаптивність до структури даних (особливо відсортованих або майже відсортованих) робить його ідеальним для практичного використання.



Чому програмісти використовують вбудовані функції Python? Timsort, реалізований у sorted і sort, є високоефективним і універсальним алгоритмом, який оптимізовано для реальних даних. Його адаптивність, швидкість і стабільність усувають потребу писати власні реалізації сортування, які зазвичай поступаються за продуктивністю.
Як запустити

Встановіть залежності:
pip install matplotlib


Запустіть програму:
python sorting_comparison.py


Перегляньте результати:

Текстові результати: sorting_results.txt.
Графіки: sorting_comparison_*.png.



Додаткові зауваження

Для поглибленого аналізу можна додати тестування на більших масивах (наприклад, 50000 елементів) або інших алгоритмах (наприклад, QuickSort).
Графіки демонструють чітку перевагу Timsort, особливо на великих і частково відсортованих даних.

